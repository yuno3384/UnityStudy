namespace UnityStudy
{
    internal class Program
    {
        static void Study()
        {
            // if문 > 분기문

            // 반복문

            // while : 하는 동안에
            //while (조건)
            //{// 이 조건이 참인 동안 아래 명령문을 실행 반복해줘
            //}
            // 조건이 변경되지 않는다면 > 값은 달라지지 않을 것
            //int a = 0;
            //while (a < 5) // 조건이 true면 무한루프에 빠져버림
            //{
            //    Console.WriteLine("무한반복");
            //    a++; // 0 > 1 > 2 > 3 > 4 // while문을 쓸때는 반드시 조건변경이 중요하다
            //}
            // 깃허브가 private이라면 : Setting > Change Visuality선택
            /*
             정수변수 num을 1로 초기화한다.
             while문을 이용해 1부터 10까지 출력한다 > 10보다 작거나 같다 , 11 이전
             출력 후 num을 1씩 증가시킨다
             */
            int num = 1; // >> 초기화
            while (num < 11)
            {
                Console.WriteLine(num);
                num++; // 1 > 2 > 3 >> 조건 변경 > 빼먹을 수도 있으니까
                // ++num; // 1 > 2 > 3 > 4 => 아무런 상관이 없다
            }


            // dowhile > 일단 해봐 > 그리고 while 조건이 true면 반복해 : 무조건 한번은 실행이 된다
            //do
            //{
            //    Console.WriteLine(num);
            //    num++; // 항상 조건에 따라 실행되는 것이기 때문에 > 조건에 맞는 횟수로 간다
            //}
            //while (num < 11); // while과 똑같으나, 최초 한번은 무조건 실행된다.

            // for
            //for (초기화(변수); 조건(boolean값); 조건변경(값 변화))
            //{
            Console.WriteLine("aa");
            // for문에서 조건이 비면? > true로 인식 > 전부 비우면( ; ; ) 그냥 무한루프
            //}
            for (int num2 = 1; num2 < 11; ++num2) // while이나 for문이나 똑같다 
            {
                Console.WriteLine(num2);
            }

            for (int n = 0; n < 9; n++)
            {
                Console.WriteLine(n);
                for (int m = 0; m < 9; m++)
                {
                    Console.WriteLine($"{n} {m}"); //CW : Console.WriteLine();
                }

            }
            // 안에 있는 반복문이 먼저 시작해서 > 그 안의 반복문이 그다음 시작됨 > 그리고 안의 반복문이 끝나고 나면 다시 바깥쪽 반복문의 조건변경이 진행
            // 항상 V자로 그린다. >선언 > (조건 > 실행 > 조건변경)(계속 반복)


            // 오늘의 숙제
            // GPT에게 기대지 마라, 남의 코드를 그대로 배끼지 마라 > 스스로 고민하고 배껴라
            // 우리가 하는 것은 작문같은 것이다.
            // 안되면 될때까지 계속 쳐봐라

            //서버만들기 > 유니티 넷코드(유니티의 자체적으로 내장되어있는 서버역할을 하는> 네트워크게임이 가능)
            // >> 예전에는 엄청 안 좋아서 계속 냅둔 걸 > 언리얼에게 밀리자 > 부랴부랴 업그레이드
            //TCP > 서버를 직업 만들어서 > 이건 기본사양 >> 쓰레드에 들어가야하는데 사람마다 이해할 수 있는 능력이 다른데
            // 사람마다 이 흐름을 잘 이해하는 사람이 있으면 잘 안그려지는 사람도 있어서 벽을 느낄 수도 있다.
            // > 재능도 노력을 하면 어떻게든 이해가 될거야
            // 연결은 이렇게 하는거다를 알아야 회사가서 일을 하지
            // 영어 > 문장만드는법도 알아야하고...
            // XR까지 끝나야 네트워트를 배울 예정
            // XR프로그램 / 아나몰픽(꺾여져있는 전광판 튀어나오는) / 네트워크 프로젝트 순이다.

            // 구구단 출력 프로그램
            // 앞자리는 2부터 뒷자리는 1부터
            //for (int i = 2; i < 10; i++)
            //{
            //    Console.WriteLine($"{i}단");
            //    for (int j = 1; j < 10; j++)
            //    {
            //        Console.WriteLine($"{i}*{j} = {i * j}");
            //    }
            //}

            // 아직도 중소기업에서는 별짓기가 나온다


            // 숙제 하나 더
            // 1에서 10까지 출력하는데 
            // 1은 홀수 입니다
            // 2는 짝수 입니다
            // 어? 근데 한글은 받침의 유무에 따라 은/는으로 나뉘잖아?
            // 일 삼 칠 : 받침 있는 홀수
            // 오 구 : 받침 없는 홀수
            // 이 사 : 받침 없는 짝수 
            // 육 팔 십 : 받침 있는 짝수
            for (int i = 1; i > 11; i++)
            {
                if (i % 2 == 0)
                {
                    Console.WriteLine($"{i}는 짝수입니다");
                }
                else if (i % 2 == 1)
                {
                    Console.WriteLine($"{i}는 홀수입니다.");
                }
            }

            // 누적합 알고리즘 > 1부터 n까지 더해주세요
            // 누적 : 값을 쌓는다 > 최종 결과는 쌓인 값 > 남아있어야 한다 > 스코프 바깥
            // 스코프 '바깥'에 변수선언 및 초기화 > 반복문 속에서 변수에 i값 계속 넣기 > 최종값을 반복문 밖에서 출력

            int save = 0;
            for (int i = 1; i < 11; i++)
            {
                save += i; //save = i + save;
                /*
                 1 - 0 + 1
                 2 - 1 + 2
                 3 - (1+2)+3
                 4 - ((1+2)+3)+4

                 */
            }
            Console.WriteLine(save);

            // 스코프 > 서로 다른 스코프에서 변수는 서로 다른 거 이므로 충돌이 안난다 > 네임스페이스
            // 하지만 스코프 위에 또 스코프가 있고, 거기서 선언한 변수명은 그 아래 스코프에서는 사용이 불가능하다.
            // 스코프 내에 있는 변수의 값은 스코프를 벗어나면 그 값이 사라진다

            //for문의 break와 continue
            // switch의 구조 - case / break / default 와 같이
            for (int i = 1; i <= 5; i++)
            {
                Console.WriteLine(i); // 1 2 3 4 5> 왜냐? 조건문 보다 먼저이므로 먼저 출력
                // 3이 될때 멈추게 하고 싶어 > 조건문 + break 
                //if(i == 3)
                //{
                //    break;// > 반복문을 중단하고 빠져나와 주세요 > 자신과 가장 가까이 있는 스코프를 탈출
                //}
                if (i == 2)
                {
                    continue; // > 반복문에서 이번 회차만 건너뛰어주세요
                    //Console.WriteLine(""); // 이 아래 구문은 작동안됨
                }
                Console.WriteLine(i); // 1 3 4 5 > 왜냐? 조건문 보다 나중이므로 조건문 조건이 성립하여 제외

            }
            for (int i = 1; i <= 5; i++)
            {
                for (int j = 1; j <= 5; j++)
                {
                    if (i == 2)
                    {
                        break;  // > 반복문을 중단하고 빠져나와 주세요 > 자신과 가장 가까이 있는 스코프를 탈출
                    }
                }

                Console.WriteLine(i); // 1 3 4 5 > 왜냐? 조건문 보다 나중이므로 조건문 조건이 성립하여 제외

            }
            for (int i = 1; i <= 5; i++)
            {
                for (int j = 1; j <= 5; j++)
                {
                    while (true)
                    {
                        if (i == 2)
                        {
                            break; // > 반복문을 중단하고 빠져나와 주세요 > 자신과 가장 가까이 있는 스코프를 탈출
                        }
                        break;

                    }

                }

                Console.WriteLine(i); // 1 3 4 5 > 왜냐? 조건문 보다 나중이므로 조건문 조건이 성립하여 제외

            }
            // break; // > 반복문을 중단하고 빠져나와 주세요 > 자신과 가장 가까이 있는 스코프를 탈출 
            // 즉 switch문의 구동은 => case 일치 > 일치 시 실행코드를 작동 > break로 switch문 스코프를 탈출하며 종료 > 다음 코드 

            // 함수 (=매소드, 프로시져)
            // 개념적으로는 코드를 재사용할 수 있도록 하나의 단위로 묶는 거
            // 만일 같은 것이 계속 반복해야 한다면 > 차라리 틀(거푸집)이 있으면 그게 편하겠다 
            // static void Main() > Main도 함수다
            // 반환형식(타입) 함수명(매개변수: 함수에 집어넣을 입력값, 여러개 가능하다)
            //  Console.WriteLine(" "); / Int.Parse() / void Main() > 끝에 괄호가 붙어있는 것은 다 함수다
            // 한정자 : static / public / private
            /*
                함수의 주요 모양 > 어떤 값을 넣으면 어떠한 행위가 일어나서 어떤 값이 나온다.
                한정자 반환형식(타입) 함수명(매개변수)
                {

                }

             */

        }
    }
}
